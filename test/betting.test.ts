import { ethers } from "hardhat";
import { expect } from "chai";
import { groth16 } from "snarkjs";
import {poseidonContract} from "circomlibjs";

describe("Betting (Simplified, dynamic proof)", function () {
  it("should accept valid zk proof and claim payout", async function () {
    const [owner, user] = await ethers.getSigners();
    // Deploy Poseidon
    const poseidonFactory = await ethers.getContractFactory(poseidonContract.generateABI(3), poseidonContract.createCode(3));
    const poseidon = await poseidonFactory.deploy();
    // Deploy BetVerifier (generated by circom/snarkjs)
    const BetVerifier = await ethers.getContractFactory("BetVerifier");
    const betVerifier = await BetVerifier.deploy();
    // Deploy Betting contract
    const Betting = await ethers.getContractFactory("Betting");
    const betting = await Betting.deploy(betVerifier.address, poseidon.address);

    // ---------- Generate Proof Dynamically ----------
    const input = { entryId: 2, stake: 10, userSecret: 123456 };

    const { proof, publicSignals } = await groth16.fullProve(
        input,
        "build/bet_js/bet.wasm",
        "build/bet_final.zkey"
    );

    // Format proof for solidity verifier
    const calldata = await groth16.exportSolidityCallData(proof, publicSignals);
    const argv = calldata
        .replace(/["[\]\s]/g, "")
        .split(",")
        .map((x: string) => BigInt(x).toString());

    const a = [argv[0], argv[1]];
    const b = [
      [argv[2], argv[3]],
      [argv[4], argv[5]],
    ];
    const c = [argv[6], argv[7]];
    const inputSignals = [argv[8]];

    // ---------- Submit Bet ----------
    await betting.connect(user).submitBet(a, b, c, inputSignals, {
      value: ethers.utils.parseEther("1"),
    });

    // Close bets
    await betting.connect(owner).closeBets(2, ethers.utils.parseEther("1"));

    // ---------- Claim Payout ----------
    const balanceBefore = await ethers.provider.getBalance(user.address);
    await betting.connect(user).claimPayout(2, 10, 123456);
    const balanceAfter = await ethers.provider.getBalance(user.address);

    expect(balanceAfter).to.be.gt(balanceBefore);
  });
});
